/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>

#include "main.h"

// Base addresses
#define PERIPH_BASE         0x40000000UL
#define AHB1PERIPH_BASE     (PERIPH_BASE + 0x00020000UL)
#define RCC_BASE            (AHB1PERIPH_BASE + 0x3800UL)
#define GPIOA_BASE          (AHB1PERIPH_BASE + 0x0000UL)

// Register addresses
#define RCC_AHB1ENR         (*(volatile uint32_t *)(RCC_BASE + 0x30))
#define GPIOA_MODER         (*(volatile uint32_t *)(GPIOA_BASE + 0x00))
#define GPIOA_IDR           (*(volatile uint32_t *)(GPIOA_BASE + 0x10))  // Input data register
#define GPIOA_ODR           (*(volatile uint32_t *)(GPIOA_BASE + 0x14))  // Output data register

// Pin definitions
#define LED_PIN             5   // PA5 for LED
#define BUTTON_PIN          0   // PA0 for User Button
#define DELAY_TIME          1000000

void delay(volatile uint32_t time)
{
    while (time--);
}

int main(void)
{
	RCC_AHB1ENR_t volatile *const pClkCtrlReg = (RCC_AHB1ENR_t *) 0x40023830;
	GPIOx_MODE_t  volatile *const pPortAModeReg = (GPIOx_MODE_t *) GPIOA_BASE;
	GPIOx_ODR_t   volatile *const pPortAOutReg  = (GPIOx_ODR_t *) (GPIOA_BASE + 0x14);


    // 1. Enable GPIOA clock (bit 0 of RCC_AHB1ENR)
    // RCC_AHB1ENR |= (1 << 0);
    pClkCtrlReg -> gpioa_en = 1;


    // 2. Configure PA5 as Output
//    GPIOA_MODER &= ~(3 << (LED_PIN * 2));   // Clear mode bits
//    GPIOA_MODER |=  (1 << (LED_PIN * 2));   // Set as output (01)
    pPortAModeReg -> pin_5 = 1;

    while (1)
    {
        // 4. Read PA0 button pin state
        uint8_t volatile pinStatus = (GPIOA_IDR >> BUTTON_PIN) & 0x01;

        if (pinStatus == 0) // Button pressed (active low)
        {
            GPIOA_ODR |= (1 << LED_PIN); // LED ON
            printf("LED ON \n");
        }
        else
        {
            GPIOA_ODR &= ~(1 << LED_PIN); // LED OFF
            printf("LED OFF\n");
        }

        delay(DELAY_TIME);
    }
}
